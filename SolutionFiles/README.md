### Dependency Injection Prework

**Branch name:** dependencyinjection-prework

Expected time required: 20 min

Using the Dagger framework, you are tasked with converting an application's classes from creating its own dependencies 
to introducing dependency injection.

In this scenario, we are looking at a `PayrollManager` that distributes payments to `Employee`s. An `Employee` 
object stores information about their salary. The PayrollManager gets employees in batches of five from the 
`HumanResourcesClient` to pay them via the `EmployeePaymentDistributor`. The `EmployeePaymentDistributor` uses a 
`PayrollTracker` to withdraw the correct funds for each employee.
`PayrollTracker` also tracks which employees have been paid.

Every class currently instantiates its own dependencies in their constructor.
Using the Dagger framework, update `PayrollManager` and classes to no longer create dependencies themselves.
Annotate the methods and classes with the required Dagger annotations we can use it to manage our dependencies for us.

##Phase 0: Before We Begin

In whatever medium you choose, draw out the dependency graph of this project, using the `PayrollManager` as the entry
point. Any classes it creates will be the Dagger root objects of your dependency graph, and those classes' dependencies will
continue the graph.  

Once we are clear on the dependencies, we'll add Dagger to this project in two phases:

##Phase 1: Prepare for DI
Here we'll update our classes to inject dependencies via the class constructors, rather than letting constructors 
instantiate dependencies themselves. This will make unit testing more manageable, and it sets us up for using Dagger 
in the next phase.

1. Update the `EmployeePaymentDistributor` and `PayrollTracker` constructors to accept their dependencies as parameters
 instead of creating them in their constructors.
2. Update the `EmployeePaymentDistributorTest` to mock the `PayrollTracker`, using the `@InjectMocks` annotation instead of
 creating a new `EmployeePaymentDistributor` ourselves. 
    2. You will have to update the test method itself with a `when(...).then(...)` statement to mock PayrollTracker's
     `getPaidEmployees` method.
3. Update the `PayrollManager`'s main method to create a new instance of `BankClient`, `PayrollTracker`, and
 `EmployeePaymentDistributor`, and pass them directly into the constructors of the classes that require them.
    3. Now our dependency construction is similar to the App class pattern we've used in the unit projects so far, where 
    every class receives its dependencies through its constructor rather than instantiating objects themselves. 
    It's now much easier to do things like unit test `EmployeePaymentDistributor`, by mocking its dependencies. 
4. Make sure the `EmployeePaymentDistributorTest` passes when running `rde wflow run dependencyinjection-prework-test
` and `PayrollManager`'s main method executes with `rde wflow run dependencyinjection-prework-main`. 
    4. Note the output of `rde wflow run dependencyinjection-prework-main`, verify we pay 5 employees and our account
     balance is decreasing.

##Phase 2: Implement DI

We're in a better place, but what's still painful about this? For example, what if we had to start tracking
our business's revenue? We might need a `RevenueTracker`, `RevenueBankClient`, or even more classes that we'll have 
to create ourselves. `PayrollManager`'s `main()` method is our entry point and where we are currently creating the
`EmployeePaymentDistributor`,`HumanResourcesClient`, and any dependencies ourselves. Instead, we'll introduce Dagger 
to manage our dependencies for us and get instances of those objects using a single Dagger component. It will also
clear the way for us to start expanding our project's functionality!

1. Annotate all relevant classes/constructors with `@Inject`, `@Module`, and `@Component(module=...)`  
2. Are any classes good candidates to be singletons? If you use the `@Singleton` annotation, remember to annotate the
 `PayrollManagerComponent` interface as well! 
3. Fill out the `BankClientModule` to *provide* a `BankClient`. 
    3. It's defined in another code package, so we can't annotate its constructor with `@Inject` ourselves.
4. Add a method signature to the `PayrollManagerComponent` interface that returns a `HumanResourcesClient`
5. Add a method signature to the `PayrollManagerComponent` interface that returns an `EmployeePaymentDistributor`
6. Update your main method to declare the Component and use it to get an
   `EmployeePaymentDistributor` and `HumanResourcesClient`. Dagger hasn't created the
   implementation yet, so it won't work, but set it to `null` for now.
7. Build your project using `rde wflow run`, or `brazil-build`, then run Brazil->Sync from Workspace 
    7. We have configured your ClassroomSnippets package to generate Dagger classes during build
8. Update your main method to create the new Component implementation generated by Dagger.
    8. Yaaay, reflect on what we've accomplished. How many times were we instantiating new objects with the `new`
       keyword after Phase 1, compared to now?
9. Make sure the `EmployeePaymentDistributorTest` still passes when running `rde wflow run dependencyinjection-prework
-test` and `PayrollManager`'s main method executes with `rde wflow run dependencyinjection-prework-main`.
    9. Make sure  the output of `rde wflow run dependencyinjection-prework-main` is similar with phase 1's output
    we should be paying our employees and our account balance should be decreasing. 

HINTs:
[I'm having trouble visualizing the dependency graph of the PayrollManager](./hints/hint-01.md)  
[I'm getting [class] cannot be provided without an @Inject constructor or an @Provides-annotated method.](./hints/hint-02.md)  
[I'm getting [class] cannot find symbol in IntelliJ](./hints/hint-03.md)  
[@Scope annotations are not allowed on @Inject constructors. Annotate the class instead.](./hints/hint-04.md)


