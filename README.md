### Dependency Injection Prework

Expected time required: 20 min

Using the Dagger framework, you are tasked with converting an application's classes from creating its own dependencies 
to introducing dependency injection.

In this scenario, we are looking at a `main.PayrollManager` that distributes payments to `main.Employee`s. An `main.Employee` 
object stores information about their salary. The main.PayrollManager gets employees in batches of five from the 
`main.HumanResourcesClient` to pay them via the `main.EmployeePaymentDistributor`. The `main.EmployeePaymentDistributor` uses a 
`main.PayrollTracker` to withdraw the correct funds for each employee.
`main.PayrollTracker` also tracks which employees have been paid.

Every class currently instantiates its own dependencies in their constructor.
Using the Dagger framework, update `main.PayrollManager` and classes to no longer create dependencies themselves.
Annotate the methods and classes with the required Dagger annotations we can use it to manage our dependencies for us.

## Phase 0: Before We Begin

In whatever medium you choose, draw out the dependency graph of this project, using the `main.PayrollManager` as the entry
point. Any classes it creates will be the Dagger root objects of your dependency graph, and those classes' dependencies will
continue the graph.  

Once we are clear on the dependencies, we'll add Dagger to this project in two phases:

## Phase 1: Prepare for DI
Here we'll update our classes to inject dependencies via the class constructors, rather than letting constructors 
instantiate dependencies themselves. This will make unit testing more manageable, and it sets us up for using Dagger 
in the next phase.

1. Update the `main.EmployeePaymentDistributor` and `main.PayrollTracker` constructors to accept their dependencies as parameters
 instead of creating them in their constructors.
2. Update the `main.EmployeePaymentDistributorTest` to mock the `main.PayrollTracker`, using the `@InjectMocks` annotation instead of
 creating a new `main.EmployeePaymentDistributor` ourselves.
3. You will have to update the test method itself with a `when(...).then(...)` statement to mock main.PayrollTracker's
     `getPaidEmployees` method.
4. Update the `main.PayrollManager`'s main method to create a new instance of `BankClient`, `main.PayrollTracker`, and
 `main.EmployeePaymentDistributor`, and pass them directly into the constructors of the classes that require them.
5. Now our dependency construction is similar to the App class pattern we've used in the unit projects so far, where 
    every class receives its dependencies through its constructor rather than instantiating objects themselves. 
    It's now much easier to do things like unit test `main.EmployeePaymentDistributor`, by mocking its dependencies. 
6. Make sure the `main.EmployeePaymentDistributorTest` passes and `main.PayrollManager`'s main method executes. 
   Verify that the output of the main method pays 5 employees and our account balance is decreasing.

## Phase 2: Implement DI

We're in a better place, but what's still painful about this? For example, what if we had to start tracking
our business's revenue? We might need a `RevenueTracker`, `RevenueBankClient`, or even more classes that we'll have 
to create ourselves. `main.PayrollManager`'s `main()` method is our entry point and where we are currently creating the
`main.EmployeePaymentDistributor`,`main.HumanResourcesClient`, and any dependencies ourselves. Instead, we'll introduce Dagger 
to manage our dependencies for us and get instances of those objects using a single Dagger component. It will also
clear the way for us to start expanding our project's functionality!

1. Annotate all relevant classes/constructors with `@Inject`, `@Module`, and `@Component(module=...)`  
2. Are any classes good candidates to be singletons? If you use the `@Singleton` annotation, remember to annotate the
 `main.PayrollManagerComponent` interface as well! 
3. Fill out the `main.BankClientModule` to *provide* a `BankClient`. It's defined in another code package, so we can't 
   annotate its constructor with `@Inject` ourselves.
4. Add a method signature to the `main.PayrollManagerComponent` interface that returns a `main.HumanResourcesClient`
5. Add a method signature to the `main.PayrollManagerComponent` interface that returns an `main.EmployeePaymentDistributor`
6. Update your main method to declare the Component and use it to get an
   `main.EmployeePaymentDistributor` and `main.HumanResourcesClient`. Dagger hasn't created the
   implementation yet, so it won't work, but set it to `null` for now.
7. Build your project to trigger Dagger to create your Component implementations.
8. Update your main method to create the new Component implementation generated by Dagger.
9. Yaaay, reflect on what we've accomplished. How many times were we instantiating new objects with the `new`
       keyword after Phase 1, compared to now?
10. Make sure the `main.EmployeePaymentDistributorTest` still passes and `main.PayrollManager`'s main method executes.
    Make sure  the output of `main.PayrollManager`'s main method is similar with phase 1's output
     we should be paying our employees and our account balance should be decreasing. 

HINTS:

[I'm having trouble visualizing the dependency graph of the main.PayrollManager](./hints/hint_01.md)  
[I'm getting [class] cannot be provided without an @Inject constructor or an @Provides-annotated method.](./hints/hint_02.md)  
[I'm getting [class] cannot find symbol in IntelliJ](./hints/hint_03.md)  
[@Scope annotations are not allowed on @Inject constructors. Annotate the class instead.](./hints/hint_04.md)


